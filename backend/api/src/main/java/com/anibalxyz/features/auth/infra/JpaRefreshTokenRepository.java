package com.anibalxyz.features.auth.infra;

import com.anibalxyz.features.auth.domain.RefreshToken;
import com.anibalxyz.features.auth.domain.RefreshTokenRepository;
import com.anibalxyz.persistence.EntityManagerProvider;
import jakarta.persistence.EntityManager;
import jakarta.persistence.NoResultException;
import java.util.List;
import java.util.Optional;

/**
 * JPA implementation of the {@link RefreshTokenRepository} interface.
 *
 * <p>This class is an adapter that bridges the domain layer's persistence port with JPA/Hibernate.
 * It handles all database operations for the {@link RefreshToken} aggregate.
 *
 * @author Generated by AI
 */
public class JpaRefreshTokenRepository implements RefreshTokenRepository {

  private final EntityManagerProvider provider;

  /**
   * Constructs a JpaRefreshTokenRepository.
   *
   * @param provider The provider for the request-scoped EntityManager.
   */
  public JpaRefreshTokenRepository(EntityManagerProvider provider) {
    this.provider = provider;
  }

  private EntityManager em() {
    return provider.get();
  }

  /** {@inheritDoc} */
  @Override
  @SuppressWarnings("resource")
  public List<RefreshToken> findAll() {
    return em().createQuery("SELECT rt FROM RefreshTokenEntity rt", RefreshTokenEntity.class)
        .getResultList().stream()
        .map(RefreshTokenEntity::toDomain)
        .toList();
  }

  /** {@inheritDoc} */
  @Override
  @SuppressWarnings("resource")
  public RefreshToken save(RefreshToken refreshToken) {
    RefreshTokenEntity entity = em().merge(RefreshTokenEntity.fromDomain(refreshToken));
    em().flush(); // Ensure the entity is persisted and ID is generated before returning
    return entity.toDomain();
  }

  /** {@inheritDoc} */
  @Override
  @SuppressWarnings("resource")
  public Optional<RefreshToken> findByToken(String token) {
    try {
      RefreshTokenEntity entity =
          em()
              .createQuery("SELECT rt FROM RefreshTokenEntity rt WHERE rt.token = :token", RefreshTokenEntity.class)
              .setParameter("token", token)
              .getSingleResult();
      return Optional.of(entity.toDomain());
    } catch (NoResultException e) {
      return Optional.empty();
    }
  }

  /** {@inheritDoc} */
  @Override
  @SuppressWarnings("resource")
  public int deleteExpiredTokens() {
    return em()
        .createQuery("DELETE FROM RefreshTokenEntity rt WHERE rt.expiryDate < CURRENT_TIMESTAMP")
        .executeUpdate();
  }
}
