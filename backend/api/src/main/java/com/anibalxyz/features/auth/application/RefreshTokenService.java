package com.anibalxyz.features.auth.application;

import com.anibalxyz.features.auth.application.env.RefreshTokenEnvironment;
import com.anibalxyz.features.auth.application.exception.InvalidCredentialsException;
import com.anibalxyz.features.auth.domain.RefreshToken;
import com.anibalxyz.features.auth.domain.RefreshTokenRepository;
import com.anibalxyz.features.users.domain.User;
import java.time.Instant;
import java.util.UUID;

/**
 * Service for handling Refresh Token operations, including generation, validation, and rotation.
 *
 * <p>This class encapsulates the logic for creating and managing refresh tokens, ensuring they are
 * securely stored and associated with a user. It acts as the primary entry point for refresh
 * token-related use cases.
 *
 * @author Generated by AI
 */
public class RefreshTokenService {

  private final RefreshTokenRepository refreshTokenRepository;
  private final RefreshTokenEnvironment env;

  /**
   * Constructs a RefreshTokenService with its required dependencies.
   *
   * @param refreshTokenRepository The repository for refresh token persistence.
   * @param env The environment configuration for refresh tokens.
   */
  public RefreshTokenService(
      RefreshTokenRepository refreshTokenRepository, RefreshTokenEnvironment env) {
    this.refreshTokenRepository = refreshTokenRepository;
    this.env = env;
  }

  /**
   * Creates and persists a new refresh token for a given user.
   *
   * <p>This method generates a unique token value, sets its expiration date based on the
   * environment configuration, and then persists it using the repository.
   *
   * @param user The user for whom the token is being created.
   * @return The newly created and persisted {@link RefreshToken}.
   */
  public RefreshToken createRefreshToken(User user) {
    Instant expiryDate = Instant.now().plus(env.JWT_REFRESH_EXPIRATION_TIME_DAYS());
    String tokenValue = UUID.randomUUID().toString();

    RefreshToken refreshToken = new RefreshToken(null, tokenValue, user, expiryDate, false);

    return refreshTokenRepository.save(refreshToken);
  }

  /**
   * Verifies a refresh token, revokes it, and creates a new one (token rotation).
   *
   * <p>This security measure ensures that each refresh token can only be used once. If a token is
   * compromised and used by an attacker, it becomes invalid for the legitimate user, and vice-versa.
   *
   * @param token The refresh token string from the client.
   * @return A new, valid {@link RefreshToken} if the old one was valid.
   * @throws InvalidCredentialsException if the token is not found, is expired, or has already been
   *     revoked.
   */
  public RefreshToken verifyAndRotate(String token) {
    RefreshToken oldToken =
        refreshTokenRepository
            .findByToken(token)
            .orElseThrow(() -> new InvalidCredentialsException("Refresh token not found"));

    if (oldToken.isExpired() || oldToken.revoked()) {
      // NOTE: Here you could add logic to invalidate all tokens for the user
      // if a revoked token is used, as it could signal a token theft attempt.
      throw new InvalidCredentialsException("Refresh token is expired or revoked");
    }

    refreshTokenRepository.save(oldToken.withRevoked(true));

    return createRefreshToken(oldToken.user());
  }
}
