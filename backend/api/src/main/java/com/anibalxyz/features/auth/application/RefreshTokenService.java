package com.anibalxyz.features.auth.application;

import com.anibalxyz.features.auth.application.env.RefreshTokenEnvironment;
import com.anibalxyz.features.auth.application.exception.InvalidCredentialsException;
import com.anibalxyz.features.auth.domain.RefreshToken;
import com.anibalxyz.features.auth.domain.RefreshTokenRepository;
import com.anibalxyz.features.users.domain.User;
import java.time.*;
import java.time.temporal.TemporalAdjusters;
import java.util.UUID;

/**
 * Service for handling Refresh Token operations, including generation, validation, and rotation.
 *
 * <p>This class encapsulates the logic for creating and managing refresh tokens, ensuring they are
 * securely stored and associated with a user. It acts as the primary entry point for refresh
 * token-related use cases.
 *
 * @author Generated by AI
 */
public class RefreshTokenService {

  private final RefreshTokenRepository refreshTokenRepository;
  private final RefreshTokenEnvironment env;

  /**
   * Constructs a RefreshTokenService with its required dependencies.
   *
   * @param refreshTokenRepository The repository for refresh token persistence.
   * @param env The environment configuration for refresh tokens.
   */
  public RefreshTokenService(
      RefreshTokenRepository refreshTokenRepository, RefreshTokenEnvironment env) {
    this.refreshTokenRepository = refreshTokenRepository;
    this.env = env;
  }

  /**
   * Creates and persists a new refresh token for a given user.
   *
   * <p>This method generates a unique token value, sets its expiration date based on the
   * environment configuration, and then persists it using the repository.
   *
   * @param user The user for whom the token is being created.
   * @return The newly created and persisted {@link RefreshToken}.
   */
  public RefreshToken createRefreshToken(User user) {
    // TODO: change the fixed ZoneId until adapted to multi-tenant
    ZonedDateTime now = ZonedDateTime.now(ZoneId.of("America/Montevideo"));

    Instant expiryDate = now.toInstant().plus(env.JWT_REFRESH_EXPIRATION_TIME_DAYS());

    if ("prod".equals(env.APP_ENV())) {
      Instant nextFriday20hs =
          now.with(TemporalAdjusters.nextOrSame(DayOfWeek.FRIDAY))
              .with(LocalTime.of(20, 0))
              .toInstant();

      expiryDate = expiryDate.isBefore(nextFriday20hs) ? expiryDate : nextFriday20hs;
    }

    RefreshToken refreshToken =
        new RefreshToken(null, UUID.randomUUID().toString(), user, expiryDate, false);

    return refreshTokenRepository.save(refreshToken);
  }

  /**
   * Verifies a refresh token, revokes it, and creates a new one (token rotation).
   *
   * <p>This security measure ensures that each refresh token can only be used once. If a token is
   * compromised and used by an attacker, it becomes invalid for the legitimate user, and vice
   * versa.
   *
   * @param token The refresh token string from the client.
   * @return A new, valid {@link RefreshToken} if the old one was valid.
   * @throws InvalidCredentialsException if the token is not found, is expired, or has already been
   *     revoked.
   */
  public RefreshToken verifyAndRotate(String token) {
    RefreshToken oldToken = verifyRefreshToken(token);
    refreshTokenRepository.save(oldToken.withRevoked(true));

    return createRefreshToken(oldToken.user());
  }

  public RefreshToken verifyRefreshToken(String token) {
    RefreshToken oldToken =
        refreshTokenRepository
            .findByToken(token)
            .orElseThrow(() -> new InvalidCredentialsException("Refresh token not found"));

    if (oldToken.isExpired() || oldToken.revoked()) {
      // NOTE: Here could add logic to invalidate all tokens for the user
      // if a revoked token is used, as it could signal a token theft attempt.
      throw new InvalidCredentialsException("Refresh token is expired or revoked");
    }

    return oldToken;
  }

  /**
   * Revokes a refresh token if it exists.
   *
   * <p>This method finds a refresh token by its value and, if found, marks it as revoked in the
   * repository. If the token is null or not found, the method does nothing.
   *
   * @param token The refresh token string to revoke.
   */
  public void revokeToken(String token) {
    if (token == null) return;

    refreshTokenRepository
        .findByToken(token)
        .ifPresent(
            (refreshToken) -> {
              refreshTokenRepository.save(refreshToken.withRevoked(true));
            });
  }

  /**
   * Cleans up expired refresh tokens from the data store.
   *
   * @return The number of deleted tokens.
   */
  public int cleanupExpiredTokens() {
    return refreshTokenRepository.deleteExpiredTokens();
  }
}
