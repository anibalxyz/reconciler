package com.anibalxyz.features.auth.application;

import com.anibalxyz.features.auth.application.exception.InvalidCredentialsException;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import java.nio.charset.StandardCharsets;
import java.time.Instant;
import java.util.Date;
import java.util.UUID;
import javax.crypto.SecretKey;

/**
 * Service for handling JSON Web Token (JWT) operations, including generation, validation, and claim
 * extraction.
 *
 * <p>This class encapsulates the logic for working with JWTs, ensuring secure and consistent token
 * management across the application.
 *
 * @author Generated by AI
 */
public class JwtService {
  private final SecretKey key;
  private final String issuer;
  private final long expirationMinutes;

  /**
   * Constructs a JwtService with the necessary JWT configuration.
   *
   * @param env The authentication environment configuration.
   * @throws IllegalArgumentException if the JWT secret is invalid or too short.
   */
  public JwtService(AuthEnvironment env) {
    if (env.JWT_SECRET() == null || env.JWT_SECRET().isBlank()) {
      throw new IllegalArgumentException("JWT_SECRET must not be null or empty");
    }
    byte[] secretBytes = env.JWT_SECRET().getBytes(StandardCharsets.UTF_8);
    if (secretBytes.length < 32) {
      throw new IllegalArgumentException("JWT_SECRET must be at least 256 bits (32 bytes)");
    }

    this.key = Keys.hmacShaKeyFor(secretBytes);
    this.issuer = env.JWT_ISSUER();
    this.expirationMinutes = env.JWT_EXPIRATION_TIME().toMinutes();
  }

  /**
   * Generates a JSON Web Token (JWT) for the given user ID.
   *
   * <p>The generated token includes the user's ID as the subject, a unique ID, issue and expiration
   * timestamps, and the configured issuer.
   *
   * @param userId The ID of the user for whom to generate the token.
   * @return A signed JWT string.
   */
  public String generateToken(Integer userId) {
    Instant now = Instant.now();
    String subject = String.valueOf(userId);

    return Jwts.builder()
        .id(UUID.randomUUID().toString())
        .subject(subject)
        .issuedAt(Date.from(now))
        .expiration(Date.from(now.plusSeconds(expirationMinutes * 60)))
        .issuer(issuer)
        .signWith(key)
        .compact();
  }

  /**
   * Validates a JWT token and returns its claims.
   *
   * @param token The JWT string to validate.
   * @return The {@link Claims} (payload) contained within the validated JWT.
   * @throws InvalidCredentialsException if the token is invalid (e.g., expired, malformed, or
   *     invalid signature).
   */
  public Claims validateToken(String token) throws InvalidCredentialsException {
    try {
      return Jwts.parser()
          .verifyWith(key) // Verify the token's digital signature.
          .build()
          .parseSignedClaims(token) // Parses the token's header and payload
          .getPayload(); // Extracts a Map containing the key-value pairs (claims) from payload
    } catch (ExpiredJwtException e) {
      throw new InvalidCredentialsException("JWT token has expired");
    } catch (MalformedJwtException | SignatureException | IllegalArgumentException e) {
      // - MalformedJwtException: The token string is not a valid JWT format
      // - SignatureException: The token's signature is invalid
      // - IllegalArgumentException: General parsing errors, often due to null/empty token
      throw new InvalidCredentialsException("Invalid JWT token");
    }
  }
}
