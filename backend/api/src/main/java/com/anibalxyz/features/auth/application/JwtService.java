package com.anibalxyz.features.auth.application;

import com.anibalxyz.features.auth.application.env.JwtEnvironment;
import com.anibalxyz.features.auth.application.exception.InvalidCredentialsException;
import io.jsonwebtoken.Claims;
import io.jsonwebtoken.ExpiredJwtException;
import io.jsonwebtoken.Jwts;
import io.jsonwebtoken.MalformedJwtException;
import io.jsonwebtoken.security.SignatureException;
import java.time.Instant;
import java.util.Date;
import java.util.UUID;

/**
 * Service for handling JSON Web Token (JWT) operations, including generation, validation, and claim
 * extraction.
 *
 * <p>This class encapsulates the logic for working with JWTs, ensuring secure and consistent token
 * management across the application.
 *
 * @author Generated by AI
 */
public class JwtService {

  private final JwtEnvironment env;

  /**
   * Constructs a JwtService with the necessary JWT configuration.
   *
   * @param env The authentication environment configuration.
   * @throws IllegalArgumentException if the JWT secret is invalid or too short.
   */
  public JwtService(JwtEnvironment env) {
    this.env = env;
  }

  /**
   * Generates a JSON Web Token (JWT) for the given user ID.
   *
   * <p>The generated token includes the user's ID as the subject, a unique ID, issue and expiration
   * timestamps, and the configured issuer.
   *
   * @param userId The ID of the user for whom to generate the token.
   * @return A signed JWT string.
   */
  public String generateToken(Integer userId) {
    return generateToken(userId, Instant.now());
  }

  /**
   * Generates a JSON Web Token (JWT) for the given user ID relative to a specific instant in time.
   *
   * <p>This method is primarily for testing purposes, allowing the creation of tokens with a
   * predictable or controlled expiration (e.g., already expired tokens).
   *
   * @param userId The ID of the user for whom to generate the token.
   * @param now The reference instant for 'now' (issuance time).
   * @return A signed JWT string.
   */
  public String generateToken(Integer userId, Instant now) {
    String subject = String.valueOf(userId);

    return Jwts.builder()
        .id(UUID.randomUUID().toString())
        .subject(subject)
        .issuedAt(Date.from(now))
        .expiration(Date.from(now.plusSeconds(env.JWT_ACCESS_EXPIRATION_TIME_MINUTES() * 60)))
        .issuer(env.JWT_ISSUER())
        .signWith(env.JWT_KEY())
        .compact();
  }

  /**
   * Validates a JWT token and returns its claims.
   *
   * @param token The JWT string to validate.
   * @return The {@link Claims} (payload) contained within the validated JWT.
   * @throws InvalidCredentialsException if the token is invalid (e.g., expired, malformed, or
   *     invalid signature).
   */
  public Claims validateToken(String token) throws InvalidCredentialsException {
    try {
      return Jwts.parser()
          .verifyWith(env.JWT_KEY()) // Verify the token's digital signature.
          .build()
          .parseSignedClaims(token) // Parses the token's header and payload
          .getPayload(); // Extracts a Map containing the key-value pairs (claims) from payload
    } catch (ExpiredJwtException e) {
      throw new InvalidCredentialsException("JWT has expired");
    } catch (MalformedJwtException | SignatureException | IllegalArgumentException e) {
      // - MalformedJwtException: The token string is not a valid JWT format
      // - SignatureException: The token's signature is invalid
      // - IllegalArgumentException: General parsing errors, often due to null/empty token
      throw new InvalidCredentialsException("Invalid JWT token");
    }
  }
}
