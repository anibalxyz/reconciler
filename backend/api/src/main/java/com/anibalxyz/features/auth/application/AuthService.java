package com.anibalxyz.features.auth.application;

import com.anibalxyz.features.auth.application.env.AuthEnvironment;
import com.anibalxyz.features.auth.application.exception.InvalidCredentialsException;
import com.anibalxyz.features.auth.application.in.LoginPayload;
import com.anibalxyz.features.auth.domain.RefreshToken;
import com.anibalxyz.features.common.application.exception.ResourceNotFoundException;
import com.anibalxyz.features.users.application.UserService;
import com.anibalxyz.features.users.domain.User;
import java.time.*;
import java.util.function.Supplier;

/**
 * Application service for authentication-related use cases.
 *
 * <p>This class orchestrates the authentication process, including credential verification, access
 * token generation, and refresh token management. It coordinates the {@link UserService}, {@link
 * JwtService}, and {@link RefreshTokenService} to provide secure authentication flows.
 *
 * @author Generated by AI
 */
public class AuthService {
  private final AuthEnvironment env;
  private final UserService userService;
  private final JwtService jwtService;
  private final RefreshTokenService refreshTokenService;
  private final Supplier<ZonedDateTime> clock;

  /**
   * Constructs an AuthService with its required dependencies.
   *
   * @param userService The service for user-related operations.
   * @param jwtService The service for JWT access token management.
   * @param refreshTokenService The service for refresh token management.
   */
  public AuthService(
      AuthEnvironment env,
      UserService userService,
      JwtService jwtService,
      RefreshTokenService refreshTokenService,
      Supplier<ZonedDateTime> clock) {
    this.env = env;
    this.userService = userService;
    this.jwtService = jwtService;
    this.refreshTokenService = refreshTokenService;
    this.clock = clock;
  }

  /**
   * Authenticates a user with the provided credentials.
   *
   * <p>This method verifies the user's email and password. If valid, it generates and returns a new
   * access and refresh token pair. To prevent user enumeration attacks, it throws a generic {@code
   * InvalidCredentialsException} for both non-existent users and incorrect passwords.
   *
   * @param payload The login request containing the user's email and password.
   * @return An {@link AuthResult} containing the new access and refresh tokens.
   * @throws InvalidCredentialsException if the credentials are not valid.
   */
  public AuthResult authenticateUser(LoginPayload payload) throws InvalidCredentialsException {
    if (env.AUTH_ENABLE_TIME_WINDOW()) {
      enforceTimeWindow();
    }
    try {
      User user = userService.getUserByEmail(payload.email());
      if (user.getPasswordHash().matches(payload.password())) {
        String accessToken = jwtService.generateToken(user.getId());
        RefreshToken refreshToken = refreshTokenService.createRefreshToken(user);
        return new AuthResult(accessToken, refreshToken);
      } else {
        throw new InvalidCredentialsException("Invalid credentials");
      }
    } catch (ResourceNotFoundException e) {
      throw new InvalidCredentialsException("Invalid credentials");
    }
  }

  /**
   * Generates a new access and refresh token pair using a valid refresh token.
   *
   * <p>This method implements refresh token rotation. It verifies the provided refresh token,
   * revokes it, and creates a new one. It then generates a new access token for the associated
   * user.
   *
   * @param refreshTokenString The refresh token string provided by the client.
   * @return A new {@link AuthResult} containing the new access and refresh tokens.
   * @throws InvalidCredentialsException if the refresh token is invalid, expired, or has been
   *     revoked.
   */
  public AuthResult refreshTokens(String refreshTokenString) {
    if (env.AUTH_ENABLE_TIME_WINDOW()) {
      enforceTimeWindow();
    }
    RefreshToken newRefreshToken = refreshTokenService.verifyAndRotate(refreshTokenString);
    String newAccessToken = jwtService.generateToken(newRefreshToken.user().getId());
    return new AuthResult(newAccessToken, newRefreshToken);
  }

  private void enforceTimeWindow() {
    ZonedDateTime zdt = clock.get();

    DayOfWeek day = zdt.getDayOfWeek();
    LocalTime time = zdt.toLocalTime();

    // Friday 20:00 â†’ Monday 08:00
    boolean isBlocked =
        (day == DayOfWeek.FRIDAY && time.isAfter(LocalTime.of(20, 0)))
            || (day == DayOfWeek.SATURDAY)
            || (day == DayOfWeek.SUNDAY)
            || (day == DayOfWeek.MONDAY && time.isBefore(LocalTime.of(8, 0)));

    if (isBlocked) {
      // TODO: then it will have a specific error code
      throw new InvalidCredentialsException("Refresh is disabled during maintenance window");
    }
  }
}
