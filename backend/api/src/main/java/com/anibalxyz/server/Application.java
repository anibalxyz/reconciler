package com.anibalxyz.server;

import com.anibalxyz.features.auth.api.AuthRoutes;
import com.anibalxyz.features.system.api.SystemRoutes;
import com.anibalxyz.features.users.api.UserRoutes;
import com.anibalxyz.persistence.PersistenceManager;
import com.anibalxyz.server.config.environment.ApplicationConfiguration;
import com.anibalxyz.server.config.modules.*;
import com.anibalxyz.server.context.JavalinContextEntityManagerProvider;
import io.javalin.Javalin;
import io.javalin.config.JavalinConfig;
import java.util.function.Consumer;

/**
 * The main application class, acting as the Composition Root.
 *
 * <p>This class is responsible for initializing and wiring together all major components of the
 * application, including the web server (Javalin), persistence layer (PersistenceManager),
 * dependency container, and all configurations and routes. It provides factory methods to create an
 * instance tailored for different environments (e.g., test, development).
 *
 * @author Generated by AI
 */
public class Application {

  private final Javalin javalin;
  private final PersistenceManager persistenceManager;
  private final ApplicationConfiguration config;

  /**
   * Private constructor to enforce instantiation via factory methods.
   *
   * @param javalin The configured Javalin instance.
   * @param persistenceManager The configured PersistenceManager.
   * @param config The application configuration.
   */
  private Application(
      Javalin javalin, PersistenceManager persistenceManager, ApplicationConfiguration config) {
    this.javalin = javalin;
    this.persistenceManager = persistenceManager;
    this.config = config;
  }

  /**
   * A general factory method that creates an {@link Application} instance based on the environment
   * specified in the configuration.
   *
   * @param config The application configuration.
   * @return A new {@code Application} instance for the appropriate environment.
   * @throws IllegalStateException if the environment in the config is unknown.
   */
  public static Application create(ApplicationConfiguration config) {
    String appEnv = config.env().APP_ENV();

    if ("test".equals(appEnv)) {
      throw new IllegalStateException(
          "For 'test' environment, directly use buildApplication() to specify feature-specific routes and configs.");
    }
    if (!"dev".equals(appEnv) && !"prod".equals(appEnv)) {
      throw new IllegalStateException("Unknown environment: " + appEnv);
    }

    // 1. Declare specific startup configurations for dev/prod
    Consumer<JavalinConfig> startupConfig =
        javalinConfig -> {
          new SwaggerConfig(javalinConfig, config.env()).apply();
        };

    // 2. Declare specific runtime configurations for dev/prod
    Consumer<Javalin> runtimeConfigs =
        server -> {
          if ("dev".equals(appEnv)) {
            server.get("/", ctx -> ctx.redirect("/swagger"));
          } else { // prod
            server.get("/", ctx -> ctx.redirect("/openapi"));
          }
        };

    // 3. Declare specific route registries for dev/prod
    Consumer<DependencyContainer> routeRegistries =
        container -> {
          new SystemRoutes(container.server(), container.systemController()).register();
          new UserRoutes(container.server(), container.userController()).register();
          new AuthRoutes(container.server(), container.authController()).register();
          new JwtMiddlewareConfig(container.server(), container.jwtMiddleware()).apply();
          new SchedulerConfig(container.server(), container.refreshTokenService()).apply();
        };

    return buildApplication(config, startupConfig, runtimeConfigs, routeRegistries);
  }

  /**
   * The private, environment-agnostic "assembler" for the application.
   *
   * <p>This method is responsible for the core assembly logic: initializing common components and
   * then applying the specific configurations and routes provided to it. It does not make decisions
   * based on the application environment.
   *
   * @param config The application configuration.
   * @param customStartupConfigs A consumer for specific startup configurations (e.g., Swagger).
   * @param customRuntimeConfigs A consumer for specific runtime configurations.
   * @param customRoutesRegistries A consumer for registering specific routes.
   * @return A fully assembled {@code Application} instance.
   */
  public static Application buildApplication(
      ApplicationConfiguration config,
      Consumer<JavalinConfig> customStartupConfigs,
      Consumer<Javalin> customRuntimeConfigs,
      Consumer<DependencyContainer> customRoutesRegistries) {

    PersistenceManager persistenceManager = new PersistenceManager(config.database());

    Consumer<JavalinConfig> finalStartupConfig =
        javalinConfig -> {
          new ServerConfig(javalinConfig, config.env()).apply();
          if (customStartupConfigs != null) customStartupConfigs.accept(javalinConfig);
        };
    Javalin server = Javalin.create(finalStartupConfig);

    DependencyContainer container =
        new DependencyContainer(
            server, config.env(), new JavalinContextEntityManagerProvider(), persistenceManager);

    new LifecycleConfig(server, persistenceManager, config.env().APP_ENV()).apply();
    new ExceptionsConfig(server).apply();

    if (customRuntimeConfigs != null) customRuntimeConfigs.accept(server);
    if (customRoutesRegistries != null) customRoutesRegistries.accept(container);

    return new Application(server, persistenceManager, config);
  }

  /**
   * @return The underlying Javalin server instance.
   */
  public Javalin javalin() {
    return javalin;
  }

  /**
   * @return The application's persistence manager.
   */
  public PersistenceManager persistenceManager() {
    return persistenceManager;
  }

  /**
   * @return The application's configuration object.
   */
  public ApplicationConfiguration config() {
    return config;
  }

  /**
   * Starts the web server on the specified port.
   *
   * @param port The port to listen on.
   */
  public void start(int port) {
    javalin.start(port);
  }

  /** Stops the web server and shuts down the persistence layer gracefully. */
  public void stop() {
    javalin.stop();
    persistenceManager.shutdown();
  }
}
