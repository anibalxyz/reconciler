package com.anibalxyz.server.config.modules.runtime;

import com.anibalxyz.features.auth.api.JwtMiddleware;
import com.anibalxyz.features.common.api.Role;
import io.javalin.Javalin;
import io.javalin.http.ForbiddenResponse;
import io.javalin.security.RouteRole;
import java.util.Set;

/**
 * Configuration module for applying JWT authentication middleware to protected routes.
 *
 * <p>This class extends {@link RuntimeConfig} to register a global `beforeMatched` handler that
 * enforces role-based access control for all endpoints.
 *
 * @author Generated by AI
 */
public class JwtMiddlewareConfig extends RuntimeConfig {
  private final JwtMiddleware jwtMiddleware;

  /**
   * Constructs a new JwtMiddlewareConfig.
   *
   * @param server The Javalin server instance.
   * @param jwtMiddleware The JWT middleware to apply.
   */
  public JwtMiddlewareConfig(Javalin server, JwtMiddleware jwtMiddleware) {
    super(server);
    this.jwtMiddleware = jwtMiddleware;
  }

  /**
   * {@inheritDoc}
   *
   * <p>Configures a `beforeMatched` handler to manage role-based security for every request. This
   * handler replaces the deprecated `AccessManager`.
   *
   * <p>The logic is as follows:
   *
   * <ul>
   *   <li>It retrieves the roles required by the matched endpoint using `ctx.routeRoles()`.
   *   <li>If an endpoint requires no roles or allows {@link Role#GUEST}, access is granted
   *       immediately.
   *   <li>If an endpoint requires any other role (like {@link Role#AUTHENTICATED}), the {@link
   *       JwtMiddleware} is executed to validate the JWT and identify the user.
   *   <li>If the token is valid, the user is assigned the {@link Role#AUTHENTICATED} role.
   *   <li>The handler then checks if the user's roles overlap with the endpoint's required roles.
   *   <li>If access is denied, a {@link ForbiddenResponse} is thrown, resulting in a 403 error.
   * </ul>
   */
  @Override
  public void apply() {
    server.beforeMatched(
        ctx -> {
          Set<RouteRole> permittedRoles = ctx.routeRoles();

          // If endpoint is public (allows GUEST or has no roles), skip auth checks
          if (permittedRoles.isEmpty() || permittedRoles.contains(Role.GUEST)) {
            return;
          }

          // For any other role, run the JWT middleware to authenticate
          jwtMiddleware.handle(ctx);

          // At this point, if jwtMiddleware didn't throw, the user is authenticated.
          // We can grant them the AUTHENTICATED role.
          Set<RouteRole> userRoles = Set.of(Role.AUTHENTICATED);

          if (userRoles.stream().noneMatch(permittedRoles::contains)) {
            throw new ForbiddenResponse("Access denied");
          }
        });
  }
}
