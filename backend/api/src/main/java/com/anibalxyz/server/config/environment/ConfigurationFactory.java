package com.anibalxyz.server.config.environment;

import com.anibalxyz.persistence.DatabaseVariables;
import com.anibalxyz.server.config.AppEnv;
import io.javalin.http.SameSite;
import io.jsonwebtoken.security.Keys;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.time.Duration;
import java.util.Arrays;
import java.util.Optional;
import java.util.Properties;
import java.util.function.Function;
import javax.crypto.SecretKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// TODO: add Hikari configuration from env variables
/**
 * A factory for creating application configuration from various sources.
 *
 * <p>This class centralizes the logic for loading configuration data, such as database credentials
 * and application-level settings. It can load settings from either system environment variables or
 * a {@code .env.*} file, adapting to different runtime environments.
 *
 * @author Generated by AI
 */
public class ConfigurationFactory {
  private static final Logger log = LoggerFactory.getLogger(ConfigurationFactory.class);

  /** Private constructor to prevent instantiation of this utility class. */
  private ConfigurationFactory() {}

  /**
   * Loads configuration specifically for the test environment.
   *
   * <p>It first checks for system environment variables. If not found, it falls back to loading
   * from the {@code .env.test} file.
   *
   * @return An {@link ApplicationConfiguration} instance for testing.
   */
  public static ApplicationConfiguration loadForTest() {
    // TODO: make this logic global -> requires a CLI argument
    // TODO: document this better
    // This usually means running inside Docker (with dotenv loaded in system environment variables)
    if (System.getenv("APP_ENV") != null) {
      return loadFromEnv();
    } else {
      return loadFromEnvFile(AppEnv.TEST);
    }
  }

  /**
   * Loads configuration from system environment variables. This is the standard method for
   * containerized environments.
   *
   * @return A new {@link ApplicationConfiguration} instance.
   */
  public static ApplicationConfiguration loadFromEnv() {
    AppEnv appEnv = AppEnv.parseFromString(getEnvVar("APP_ENV", System::getenv));
    log.info("Loading configuration from system environment variables");
    return loadEnvironmentVariables(System::getenv, appEnv);
  }

  /**
   * Loads configuration from a {@code .env.{appEnv}} file from the project's root.
   *
   * @param appEnv The environment to load configuration for.
   * @return A new {@link ApplicationConfiguration} instance.
   */
  public static ApplicationConfiguration loadFromEnvFile(AppEnv appEnv) {
    if (appEnv == null) {
      throw new IllegalArgumentException("appEnv cannot be null");
    }
    Properties props = new Properties();
    String appEnvString = appEnv.toString().toLowerCase();
    try (InputStream in = new FileInputStream("../.env." + appEnvString)) {
      props.load(in);
    } catch (IOException e) {
      throw new IllegalStateException("Could not load .env file for configuration", e);
    }
    log.info("Loading configuration for the '{}' environment", appEnvString);
    return loadEnvironmentVariables(props::getProperty, appEnv);
  }

  /**
   * Core method that loads all environment variables from the specified source.
   *
   * @param appEnv The application environment (TEST, DEV, or PROD)
   * @return A new {@link ApplicationConfiguration} instance
   */
  private static ApplicationConfiguration loadEnvironmentVariables(
      Function<String, String> callback, AppEnv appEnv) {

    String dbName = getEnvVar("DB_NAME", callback);
    String dbUser = getEnvVar("DB_USER", callback);
    String dbPassword = getEnvVar("DB_PASSWORD", callback);
    String dbPort = getEnvVar("DB_PORT", callback);
    String dbHost = getEnvVar("DB_HOST", callback);
    String apiProtocol = getEnvVar("API_PROTOCOL", callback, true);
    if (apiProtocol == null || apiProtocol.isBlank()) {
      apiProtocol = appEnv == AppEnv.PROD ? "https" : "http";
    }
    String apiHost = getEnvVar("API_HOST", callback);
    int apiPort = Integer.parseInt(getEnvVar("API_PORT", callback));
    String apiPrefix = getEnvVar("API_PREFIX", callback);
    String apiUrl = apiProtocol + "://" + apiHost + ":" + apiPort + apiPrefix;
    String frontendProtocol =
        Optional.ofNullable(getEnvVar("FRONTEND_PROTOCOL", callback, true))
            .filter(s -> !s.isBlank())
            .orElse(appEnv == AppEnv.PROD ? "https" : "http");

    String corsOriginsRaw = getEnvVar("CORS_ALLOWED_ORIGINS", callback, true);
    String[] corsAllowedOrigins;
    if (corsOriginsRaw == null || corsOriginsRaw.isBlank()) {
      corsAllowedOrigins = new String[0];
    } else {
      corsAllowedOrigins =
          Arrays.stream(corsOriginsRaw.split(","))
              .map(String::trim)
              .filter(s -> !s.isEmpty())
              .map(origin -> frontendProtocol + "://" + origin)
              .toArray(String[]::new);
    }

    String contactEmail = getEnvVar("CONTACT_EMAIL", callback);

    /*
      *   public JwtService(JwtEnvironment env) {
      // TODO: move this validation and 'key' & 'expirationMinutes' typing to ConfigurationFactory

      byte[] secretBytes = env.JWT_SECRET().getBytes(StandardCharsets.UTF_8);
      if (secretBytes.length < 32) {
        throw new IllegalArgumentException("JWT_SECRET must be at least 256 bits (32 bytes)");
      }

      this.key = Keys.hmacShaKeyFor(secretBytes);
      this.issuer = env.JWT_ISSUER();
      this.expirationMinutes = env.JWT_ACCESS_EXPIRATION_TIME_MINUTES().toMinutes();
    }
      * */

    // JWT configuration
    String jwtSecret = getEnvVar("JWT_SECRET", callback);
    if (jwtSecret == null || jwtSecret.isBlank()) {
      throw new IllegalArgumentException("JWT_SECRET must not be null or empty");
    }
    byte[] secretBytes = jwtSecret.getBytes(StandardCharsets.UTF_8);
    if (secretBytes.length < 32) {
      throw new IllegalArgumentException("JWT_SECRET must be at least 256 bits (32 bytes)");
    }
    SecretKey jwtKey = Keys.hmacShaKeyFor(secretBytes);
    String jwtIssuer = getEnvVar("JWT_ISSUER", callback);
    long jwtAccessExpirationTimeMinutes =
        Duration.ofMinutes(
                Long.parseLong(getEnvVar("JWT_ACCESS_EXPIRATION_TIME_MINUTES", callback)))
            .toMinutes();
    Duration jwtRefreshExpirationTime =
        Duration.ofDays(Long.parseLong(getEnvVar("JWT_REFRESH_EXPIRATION_TIME_DAYS", callback)));

    int bcryptLogRounds = Integer.parseInt(getEnvVar("BCRYPT_LOG_ROUNDS", callback));

    String authCookieDomain = getEnvVar("AUTH_COOKIE_DOMAIN", callback, true);
    Boolean authCookieSecure = appEnv == AppEnv.PROD;
    String authCookiePath = apiPrefix + getEnvVar("AUTH_COOKIE_PATH", callback);

    SameSite authCookieSameSite;
    try {
      authCookieSameSite =
          SameSite.valueOf(getEnvVar("AUTH_COOKIE_SAMESITE", callback).toUpperCase());
    } catch (IllegalArgumentException e) {
      throw new IllegalStateException("Invalid value for AUTH_COOKIE_SAMESITE: " + e.getMessage());
    }

    boolean authEnableTimeWindow = appEnv == AppEnv.PROD;

    AppEnvironmentSource env =
        new AppEnvironmentSource(
            appEnv,
            apiUrl,
            apiPort,
            apiPrefix,
            corsAllowedOrigins,
            contactEmail,
            bcryptLogRounds,
            jwtSecret,
            jwtKey,
            jwtIssuer,
            jwtAccessExpirationTimeMinutes,
            jwtRefreshExpirationTime,
            authCookieSecure,
            authCookieDomain.isBlank() ? null : authCookieDomain,
            authCookieSameSite,
            authCookiePath,
            authEnableTimeWindow);

    ApplicationConfiguration result =
        new ApplicationConfiguration(
            env, DatabaseVariables.generate(dbHost, dbPort, dbName, dbUser, dbPassword));
    if (appEnv != AppEnv.PROD) {
      // Some values will no be correctly shown. e.g. CORS_ALLOWED_ORIGINS
      log.debug("Loaded Configuration: {}", result);
    }
    return result;
  }

  /**
   * Safely retrieves a configuration value from a given source.
   *
   * @param name The name of the configuration property to retrieve
   * @param source A function that takes the property name and returns its value
   * @param allowEmpty If true, allows null or blank values; if false, throws exception
   * @return The value of the configuration property
   * @throws IllegalStateException if allowEmpty is false and the property is missing or blank
   */
  private static String getEnvVar(
      String name, Function<String, String> source, boolean allowEmpty) {
    String value = source.apply(name);
    if (!allowEmpty && (value == null || value.isBlank())) {
      throw new IllegalStateException("Missing required configuration property: " + name);
    }
    return value;
  }

  /**
   * Safely retrieves a required configuration value from a given source.
   *
   * @param name The name of the configuration property to retrieve
   * @param source A function that provides the value based on the name
   * @return The non-blank value of the configuration property
   * @throws IllegalStateException if the property is missing or blank
   */
  private static String getEnvVar(String name, Function<String, String> source) {
    return getEnvVar(name, source, false);
  }
}
