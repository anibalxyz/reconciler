package com.anibalxyz.server.config.environment;

import com.anibalxyz.persistence.DatabaseVariables;
import io.javalin.http.SameSite;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.util.Properties;
import java.util.function.Function;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A factory for creating application configuration from various sources.
 *
 * <p>This class centralizes the logic for loading configuration data, such as database credentials
 * and application-level settings. It can load settings from either system environment variables or
 * a {@code .env.*} file, adapting to different runtime environments.
 *
 * @author Generated by AI
 */
public class ConfigurationFactory {
  // Fixed default port in PostgreSQL container
  private static final String DEFAULT_DB_PORT = "5432";
  // Used when running locally because container is mapped to localhost
  private static final String DEFAULT_LOCAL_HOST = "localhost";
  private static final Logger log = LoggerFactory.getLogger(ConfigurationFactory.class);

  /** Private constructor to prevent instantiation of this utility class. */
  private ConfigurationFactory() {}

  /**
   * Loads configuration specifically for the test environment.
   *
   * <p>It first checks for system environment variables. If not found, it falls back to loading
   * from the {@code .env.test} file.
   *
   * @return An {@link ApplicationConfiguration} instance for testing.
   */
  public static ApplicationConfiguration loadForTest() {
    if (System.getenv("APP_ENV") != null) {
      log.info("Loading configuration from system environment variables");
      return loadFromEnv();
    }
    log.info("Loading configuration from dotenv file");
    return loadFromEnvFile("test");
  }

  // TODO: add Hikari configuration from env variables
  /**
   * Loads configuration from system environment variables. This is the standard method for
   * containerized environments.
   *
   * @return A new {@link ApplicationConfiguration} instance.
   */
  public static ApplicationConfiguration loadFromEnv() {
    String appEnv = getEnvVar("APP_ENV", System::getenv);
    String host = getEnvVar("DB_HOST", System::getenv);
    String name = getEnvVar("DB_NAME", System::getenv);
    String user = getEnvVar("DB_USER", System::getenv);
    String password = getEnvVar("DB_PASSWORD", System::getenv);

    String apiHost = getEnvVar("API_HOST", System::getenv);
    String apiPort = getEnvVar("API_PORT", System::getenv);
    String apiPublicPrefix = getEnvVar("API_PUBLIC_PREFIX", System::getenv);
    String apiUrl =
        appEnv.equals("prod")
            ? "https://" + apiHost + apiPublicPrefix // port =
            : "http://" + apiHost + ":" + apiPort;

    String contactEmail = getEnvVar("CONTACT_EMAIL", System::getenv);

    // jwt
    String jwtSecret = getEnvVar("JWT_SECRET", System::getenv);
    String jwtIssuer = getEnvVar("JWT_ISSUER", System::getenv);
    Duration jwtAccessExpirationTime =
        Duration.ofMinutes(
            Long.parseLong(getEnvVar("JWT_ACCESS_EXPIRATION_TIME_MINUTES", System::getenv)));
    Duration jwtRefreshExpirationTime =
        Duration.ofDays(
            Long.parseLong(getEnvVar("JWT_REFRESH_EXPIRATION_TIME_DAYS", System::getenv)));

    int bcryptLogRounds = Integer.parseInt(getEnvVar("BCRYPT_LOG_ROUNDS", System::getenv));

    String authCookieDomain = getEnvVar("AUTH_COOKIE_DOMAIN", System::getenv, true);
    Boolean authCookieSecure = appEnv.equals("prod");
    String authCookiePath = apiPublicPrefix + "/auth/refresh";

    SameSite authCookieSameSite;
    try {
      authCookieSameSite =
          SameSite.valueOf(getEnvVar("AUTH_COOKIE_SAMESITE", System::getenv).toUpperCase());
    } catch (IllegalArgumentException e) {
      throw new IllegalStateException("Invalid value for AUTH_COOKIE_SAMESITE:" + e.getMessage());
    }

    AppEnvironmentSource env =
        new AppEnvironmentSource(
            appEnv,
            bcryptLogRounds,
            apiUrl,
            contactEmail,
            jwtSecret,
            jwtIssuer,
            jwtAccessExpirationTime,
            jwtRefreshExpirationTime,
            authCookieSecure,
            authCookieDomain.isBlank() ? null : authCookieDomain,
            authCookieSameSite,
            authCookiePath);

    return new ApplicationConfiguration(
        env, DatabaseVariables.generate(host, DEFAULT_DB_PORT, name, user, password));
  }

  /**
   * Loads configuration from a {@code .env.{appEnv}} file from the project's root. This is
   * primarily used for local development and testing.
   *
   * @param appEnv The environment suffix (e.g., "development", "test").
   * @return A new {@link ApplicationConfiguration} instance.
   * @throws IllegalStateException if the specified .env file cannot be loaded.
   */
  public static ApplicationConfiguration loadFromEnvFile(String appEnv) {
    Properties props = new Properties();
    try (InputStream in = new FileInputStream("../.env." + appEnv)) {
      props.load(in);
    } catch (IOException e) {
      throw new IllegalStateException("Could not load .env file for configuration", e);
    }
    String port = getEnvVar("DB_PORT", props::getProperty);
    String name = getEnvVar("DB_NAME", props::getProperty);
    String user = getEnvVar("DB_USER", props::getProperty);
    String password = getEnvVar("DB_PASSWORD", props::getProperty);
    String contactEmail = getEnvVar("CONTACT_EMAIL", props::getProperty);

    String apiHost = getEnvVar("API_HOST", props::getProperty);
    String apiPort = getEnvVar("API_PORT", props::getProperty);
    String apiPublicPrefix = getEnvVar("API_PUBLIC_PREFIX", props::getProperty);
    String apiUrl =
        appEnv.equals("prod")
            ? "https://" + apiHost + apiPublicPrefix // port =
            : "http://" + apiHost + ":" + apiPort;

    // jwt
    String jwtSecret = getEnvVar("JWT_SECRET", props::getProperty);
    String jwtIssuer = getEnvVar("JWT_ISSUER", props::getProperty);
    Duration jwtAccessExpirationTime =
        Duration.ofMinutes(
            Long.parseLong(getEnvVar("JWT_ACCESS_EXPIRATION_TIME_MINUTES", props::getProperty)));
    Duration jwtRefreshExpirationTime =
        Duration.ofDays(
            Long.parseLong(getEnvVar("JWT_REFRESH_EXPIRATION_TIME_DAYS", props::getProperty)));

    int bcryptLogRounds = Integer.parseInt(getEnvVar("BCRYPT_LOG_ROUNDS", props::getProperty));

    String authCookieDomain = getEnvVar("AUTH_COOKIE_DOMAIN", props::getProperty, true);
    Boolean authCookieSecure = appEnv.equals("prod");
    String authCookiePath = apiPublicPrefix + "/auth/refresh";

    SameSite authCookieSameSite;
    try {
      authCookieSameSite =
          SameSite.valueOf(getEnvVar("AUTH_COOKIE_SAMESITE", props::getProperty).toUpperCase());
    } catch (IllegalArgumentException e) {
      throw new IllegalStateException("Invalid value for AUTH_COOKIE_SAMESITE:" + e.getMessage());
    }
    AppEnvironmentSource env =
        new AppEnvironmentSource(
            appEnv,
            bcryptLogRounds,
            apiUrl,
            contactEmail,
            jwtSecret,
            jwtIssuer,
            jwtAccessExpirationTime,
            jwtRefreshExpirationTime,
            authCookieSecure,
            authCookieDomain.isBlank() ? null : authCookieDomain,
            authCookieSameSite,
            authCookiePath);

    return new ApplicationConfiguration(
        env, DatabaseVariables.generate(DEFAULT_LOCAL_HOST, port, name, user, password));
  }

  // TODO: env variables origin could be selected here
  /**
   * Safely retrieves a configuration value from a given source.
   *
   * <p>This helper method abstracts the process of reading a configuration property. It can either
   * enforce that the property is not null or blank, or allow it to be empty based on the {@code
   * allowEmpty} flag. This provides a clear, consistent error message for required properties,
   * which helps in diagnosing configuration issues quickly.
   *
   * @param name The name of the configuration property to retrieve (e.g., "DB_HOST").
   * @param source A function that takes the property name and returns its value (e.g.,
   *     System::getenv or props::getProperty).
   * @param allowEmpty If {@code true}, the method will return the value even if it is null or
   *     blank. If {@code false}, it will throw an exception for null or blank values.
   * @return The value of the configuration property. If {@code allowEmpty} is true, this can be
   *     {@code null} or a blank string. If {@code allowEmpty} is false, this will be a non-blank
   *     string.
   * @throws IllegalStateException if {@code allowEmpty} is false and the property is missing (null)
   *     or blank.
   */
  private static String getEnvVar(String name, Function<String, String> source, boolean allowEmpty)
      throws IllegalStateException {
    String value = source.apply(name);
    if (!allowEmpty && (value == null || value.isBlank())) {
      throw new IllegalStateException("Missing required configuration property: " + name);
    }
    return value;
  }

  /**
   * Safely retrieves a required configuration value from a given source, ensuring it is not blank.
   *
   * <p>This is a convenience overload for {@link #getEnvVar(String, Function, boolean)} that always
   * enforces the property to exist and have a non-blank value.
   *
   * @param name The name of the configuration property to retrieve.
   * @param source A function that provides the value based on the name.
   * @return The non-blank value of the configuration property.
   * @throws IllegalStateException if the property is missing (null) or blank.
   */
  private static String getEnvVar(String name, Function<String, String> source) {
    return getEnvVar(name, source, false);
  }
}
