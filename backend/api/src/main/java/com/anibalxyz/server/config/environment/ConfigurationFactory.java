package com.anibalxyz.server.config.environment;

import com.anibalxyz.persistence.DatabaseVariables;
import com.anibalxyz.server.config.AppEnv;
import io.javalin.http.SameSite;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.time.Duration;
import java.util.Properties;
import java.util.function.Function;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

// TODO: add Hikari configuration from env variables
// TODO: do not use DEFAULTS by assuming we are inside Docker -> use always envars
/**
 * A factory for creating application configuration from various sources.
 *
 * <p>This class centralizes the logic for loading configuration data, such as database credentials
 * and application-level settings. It can load settings from either system environment variables or
 * a {@code .env.*} file, adapting to different runtime environments.
 *
 * @author Generated by AI
 */
public class ConfigurationFactory {
  /** Fixed default port in PostgreSQL container */
  private static final String DEFAULT_DB_PORT = "5432";

  /** Used when running locally because the container's host is mapped to localhost */
  private static final String DEFAULT_DB_HOST = "localhost";

  private static final Logger log = LoggerFactory.getLogger(ConfigurationFactory.class);

  /** Private constructor to prevent instantiation of this utility class. */
  private ConfigurationFactory() {}

  /**
   * Loads configuration specifically for the test environment.
   *
   * <p>It first checks for system environment variables. If not found, it falls back to loading
   * from the {@code .env.test} file.
   *
   * @return An {@link ApplicationConfiguration} instance for testing.
   */
  public static ApplicationConfiguration loadForTest() {
    // TODO: make this logic global -> requires a CLI argument
    // This usually means running inside Docker (with dotenv loaded in system environment variables)
    if (System.getenv("APP_ENV") != null) {
      return loadFromEnv();
    } else {
      return loadFromEnvFile(AppEnv.TEST);
    }
  }

  /**
   * Loads configuration from system environment variables. This is the standard method for
   * containerized environments.
   *
   * @return A new {@link ApplicationConfiguration} instance.
   */
  public static ApplicationConfiguration loadFromEnv() {
    log.info("Loading configuration from system environment variables");
    AppEnv appEnv = AppEnv.parseFromString(getEnvVar("APP_ENV", System::getenv));

    return loadEnvironmentVariables(VarSource.SYSTEM, appEnv);
  }

  /**
   * Loads configuration from a {@code .env.{appEnv}} file from the project's root.
   *
   * @param appEnv The environment to load configuration for.
   * @return A new {@link ApplicationConfiguration} instance.
   */
  public static ApplicationConfiguration loadFromEnvFile(AppEnv appEnv) {
    if (appEnv == null) {
      throw new IllegalArgumentException("appEnv cannot be null");
    }
    log.info("Loading configuration from dotenv file");
    return loadEnvironmentVariables(VarSource.FILE, appEnv);
  }

  /**
   * Core method that loads all environment variables from the specified source.
   *
   * @param varSource The source to load variables from (SYSTEM or FILE)
   * @param appEnv The application environment (TEST, DEV, or PROD)
   * @return A new {@link ApplicationConfiguration} instance
   */
  private static ApplicationConfiguration loadEnvironmentVariables(
      VarSource varSource, AppEnv appEnv) {

    Function<String, String> callback;
    String dbHost;
    String dbPort;

    switch (varSource) {
      case FILE:
        Properties props = new Properties();
        try (InputStream in = new FileInputStream("../.env." + appEnv.toString().toLowerCase())) {
          props.load(in);
        } catch (IOException e) {
          throw new IllegalStateException("Could not load .env file for configuration", e);
        }
        callback = props::getProperty;
        dbHost = DEFAULT_DB_HOST;
        dbPort = getEnvVar("DB_PORT", callback);
        break;

      case SYSTEM:
        callback = System::getenv;
        dbHost = getEnvVar("DB_HOST", callback);
        dbPort = DEFAULT_DB_PORT;
        break;

      default:
        throw new IllegalStateException("Unexpected VarSource: " + varSource);
    }

    String dbName = getEnvVar("DB_NAME", callback);
    String dbUser = getEnvVar("DB_USER", callback);
    String dbPassword = getEnvVar("DB_PASSWORD", callback);

    String apiHost = getEnvVar("API_HOST", callback);
    String apiPort = getEnvVar("API_PORT", callback);
    String apiPublicPrefix = getEnvVar("API_PUBLIC_PREFIX", callback);
    String apiUrl =
        appEnv == AppEnv.PROD
            ? "https://" + apiHost + apiPublicPrefix
            : "http://" + apiHost + ":" + apiPort;

    String contactEmail = getEnvVar("CONTACT_EMAIL", callback);

    // JWT configuration
    String jwtSecret = getEnvVar("JWT_SECRET", callback);
    String jwtIssuer = getEnvVar("JWT_ISSUER", callback);
    Duration jwtAccessExpirationTime =
        Duration.ofMinutes(
            Long.parseLong(getEnvVar("JWT_ACCESS_EXPIRATION_TIME_MINUTES", callback)));
    Duration jwtRefreshExpirationTime =
        Duration.ofDays(Long.parseLong(getEnvVar("JWT_REFRESH_EXPIRATION_TIME_DAYS", callback)));

    int bcryptLogRounds = Integer.parseInt(getEnvVar("BCRYPT_LOG_ROUNDS", callback));

    String authCookieDomain = getEnvVar("AUTH_COOKIE_DOMAIN", callback, true);
    Boolean authCookieSecure = appEnv == AppEnv.PROD;
    String authCookiePath = apiPublicPrefix + "/auth";

    SameSite authCookieSameSite;
    try {
      authCookieSameSite =
          SameSite.valueOf(getEnvVar("AUTH_COOKIE_SAMESITE", callback).toUpperCase());
    } catch (IllegalArgumentException e) {
      throw new IllegalStateException("Invalid value for AUTH_COOKIE_SAMESITE: " + e.getMessage());
    }

    boolean authEnableTimeWindow = appEnv == AppEnv.PROD;

    AppEnvironmentSource env =
        new AppEnvironmentSource(
            appEnv,
            bcryptLogRounds,
            apiUrl,
            contactEmail,
            jwtSecret,
            jwtIssuer,
            jwtAccessExpirationTime,
            jwtRefreshExpirationTime,
            authCookieSecure,
            authCookieDomain.isBlank() ? null : authCookieDomain,
            authCookieSameSite,
            authCookiePath,
            authEnableTimeWindow);

    return new ApplicationConfiguration(
        env, DatabaseVariables.generate(dbHost, dbPort, dbName, dbUser, dbPassword));
  }

  /**
   * Safely retrieves a configuration value from a given source.
   *
   * @param name The name of the configuration property to retrieve
   * @param source A function that takes the property name and returns its value
   * @param allowEmpty If true, allows null or blank values; if false, throws exception
   * @return The value of the configuration property
   * @throws IllegalStateException if allowEmpty is false and the property is missing or blank
   */
  private static String getEnvVar(
      String name, Function<String, String> source, boolean allowEmpty) {
    String value = source.apply(name);
    if (!allowEmpty && (value == null || value.isBlank())) {
      throw new IllegalStateException("Missing required configuration property: " + name);
    }
    return value;
  }

  /**
   * Safely retrieves a required configuration value from a given source.
   *
   * @param name The name of the configuration property to retrieve
   * @param source A function that provides the value based on the name
   * @return The non-blank value of the configuration property
   * @throws IllegalStateException if the property is missing or blank
   */
  private static String getEnvVar(String name, Function<String, String> source) {
    return getEnvVar(name, source, false);
  }

  // TODO: remove it once decoupled from docker infra as it will be no longer used
  public enum VarSource {
    SYSTEM,
    FILE,
  }
}
