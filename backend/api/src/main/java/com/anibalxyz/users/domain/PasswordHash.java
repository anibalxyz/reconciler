package com.anibalxyz.users.domain;

import com.anibalxyz.users.domain.exception.InvalidPasswordFormatException;
import java.util.regex.Pattern;
import org.jetbrains.annotations.NotNull;
import org.mindrot.jbcrypt.BCrypt;

/**
 * Represents a hashed password as an immutable value object.
 *
 * <p>This class encapsulates the logic for creating, validating, and verifying password hashes
 * using the BCrypt algorithm. It ensures that plain-text passwords are never stored or passed
 * around the domain, and prevents accidental logging of the hash value.
 *
 * @param value The BCrypt hashed password string.
 * @author Generated by AI
 */
public record PasswordHash(String value) {
  public static final int MIN_LENGTH = 8;
  public static final int MAX_LENGTH = 72;
  private static final Pattern BCRYPT_PATTERN =
      Pattern.compile("\\A\\$2a\\$\\d\\d\\$[./0-9A-Za-z]{53}");

  /**
   * Compact constructor for the PasswordHash record. It validates that the provided value is a
   * valid BCrypt hash.
   *
   * @throws IllegalArgumentException if the hash format is invalid.
   */
  public PasswordHash {
    if (!isValidHash(value)) {
      throw new IllegalArgumentException("Invalid password hash format");
    }
  }

  /**
   * Validates if a string conforms to the BCrypt hash format.
   *
   * @param hash The hash string to validate.
   * @return {@code true} if the hash is valid, {@code false} otherwise.
   */
  public static boolean isValidHash(String hash) {
    return hash != null && BCRYPT_PATTERN.matcher(hash).matches();
  }

  private static void validateRawPassword(String raw) {
    if (raw == null || raw.isBlank()) {
      throw new InvalidPasswordFormatException("Password cannot be null or empty");
    }
    if (raw.length() < MIN_LENGTH) {
      throw new InvalidPasswordFormatException("Password must be at least " + MIN_LENGTH + " characters long");
    }
    if (raw.length() > MAX_LENGTH) {
      throw new InvalidPasswordFormatException("Password cannot be longer than " + MAX_LENGTH + " characters");
    }
  }

  /**
   * Creates a new {@code PasswordHash} instance from a plain-text password. The password will be
   * salted and hashed using BCrypt.
   *
   * @param raw The plain-text password to hash.
   * @param saltRounds The log2 of the number of rounds of hashing to apply.
   * @return A new {@code PasswordHash} instance.
   * @throws InvalidPasswordFormatException if the raw password does not meet complexity
   *     requirements.
   */
  public static PasswordHash generate(String raw, int saltRounds) {
    validateRawPassword(raw);
    return new PasswordHash(BCrypt.hashpw(raw, BCrypt.gensalt(saltRounds)));
  }

  /**
   * Verifies a plain-text password against the stored hash.
   *
   * @param raw The plain-text password to check.
   * @return {@code true} if the password matches the hash, {@code false} otherwise.
   */
  public boolean matches(String raw) {
    return BCrypt.checkpw(raw, value);
  }

  @NotNull
  @Override
  /**
   * Overrides toString to prevent leaking the hash value in logs.
   *
   * @return A fixed-string mask "********".
   */
  public String toString() {
    return "********"; // prevents data leaks through logs
  }
}
