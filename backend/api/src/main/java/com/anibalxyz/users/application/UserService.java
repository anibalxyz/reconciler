package com.anibalxyz.users.application;

import com.anibalxyz.application.exception.ConflictException;
import com.anibalxyz.application.exception.InvalidInputException;
import com.anibalxyz.application.exception.ResourceNotFoundException;
import com.anibalxyz.users.application.in.UserUpdatePayload;
import com.anibalxyz.users.domain.Email;
import com.anibalxyz.users.domain.PasswordHash;
import com.anibalxyz.users.domain.User;
import com.anibalxyz.users.domain.UserRepository;
import java.util.List;

/**
 * Application service for user-related use cases.
 *
 * <p>This class orchestrates the domain layer to perform operations such as creating, retrieving,
 * updating, and deleting users. It contains the application-specific business logic and acts as a
 * boundary between the presentation layer (API) and the domain layer.
 *
 * @author Generated by AI
 */
public class UserService {
  private final UserRepository userRepository;
  private final UsersEnvironment env;

  /**
   * Constructs a UserService with its required dependencies.
   *
   * @param userRepository The repository for user data persistence.
   * @param env An interface for providing environment-specific configuration, such as BCrypt
   *     rounds.
   */
  public UserService(UserRepository userRepository, UsersEnvironment env) {
    this.userRepository = userRepository;
    this.env = env;
  }

  /**
   * Retrieves all users.
   *
   * @return A list of all {@link User} objects.
   */
  public List<User> getAllUsers() {
    return userRepository.findAll();
  }

  /**
   * Retrieves a single user by their ID.
   *
   * @param id The ID of the user to retrieve.
   * @return The found {@link User} object.
   * @throws ResourceNotFoundException if no user with the given ID is found.
   */
  public User getUserById(int id) throws ResourceNotFoundException {
    return userRepository
        .findById(id)
        .orElseThrow(() -> new ResourceNotFoundException("User with id " + id + " not found"));
  }

  /**
   * Creates a new user based on the provided payload.
   *
   * @param payload The data for the new user, implementing {@link UserUpdatePayload}.
   * @return The newly created and persisted {@link User} object.
   * @throws ConflictException if the email is already in use.
   * @throws InvalidInputException if the email or password format is invalid.
   */
  public User createUser(UserUpdatePayload payload)
      throws ConflictException, InvalidInputException {
    try {
      Email email = new Email(payload.email());
      userRepository
          .findByEmail(email)
          .ifPresent(
              user -> {
                throw new ConflictException("Email already in use. Please use another");
              });
      PasswordHash passwordHash =
          PasswordHash.generate(payload.password(), env.BCRYPT_LOG_ROUNDS());
      return userRepository.save(new User(payload.name(), email, passwordHash));
    } catch (IllegalArgumentException e) {
      throw new InvalidInputException(e.getMessage());
    }
  }

  /**
   * Updates an existing user's information.
   *
   * <p>Fields in the payload are applied conditionally. A null field in the payload means that
   * property will not be updated.
   *
   * @param id The ID of the user to update.
   * @param payload A {@link UserUpdatePayload} containing the fields to update.
   * @return The updated {@link User} object.
   * @throws ResourceNotFoundException if no user with the given ID is found.
   * @throws ConflictException if the new email is already in use by another user.
   * @throws InvalidInputException if the email or password format is invalid.
   */
  public User updateUserById(Integer id, UserUpdatePayload payload)
      throws ConflictException, ResourceNotFoundException, InvalidInputException {
    User user =
        userRepository
            .findById(id)
            .orElseThrow(() -> new ResourceNotFoundException("User with id " + id + " not found"));
    try {
      if (payload.name() != null) {
        user = user.withName(payload.name());
      }
      if (payload.email() != null) {
        Email newEmail = new Email(payload.email());

        // Avoids an unneeded DB query (findByEmail)
        if (!newEmail.equals(user.getEmail())) {
          userRepository
              .findByEmail(newEmail)
              .ifPresent(
                  existingUser -> {
                    throw new ConflictException("Email already in use. Please use another");
                  });
          user = user.withEmail(newEmail);
        }
      }

      if (payload.password() != null) {
        user =
            user.withPasswordHash(
                PasswordHash.generate(payload.password(), env.BCRYPT_LOG_ROUNDS()));
      }
      return userRepository.save(user);
    } catch (IllegalArgumentException e) {
      throw new InvalidInputException(e.getMessage());
    }
  }

  /**
   * Deletes a user by their ID.
   *
   * @param id The ID of the user to delete.
   * @throws ResourceNotFoundException if the user could not be found or was not deleted.
   */
  public void deleteUserById(int id) throws ResourceNotFoundException {
    boolean wasDeleted = userRepository.deleteById(id);
    if (!wasDeleted) {
      throw new ResourceNotFoundException("User with id " + id + " not found");
    }
  }
}
